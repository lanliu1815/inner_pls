#' Generate a random semi-orthogonal matrix.
#'
#' The matrix is generated by standardizing a matrix of independent U(0,1)
#' variates.
#'
#' @param r,u \code{1<=u<=r}.
#' @return A matrix, which is the desired one.
rsomat<-function(u, r){

  if(u>r){
    stop("Columns more than rows!")
  }
  if(u==0){
    stop("u==0!")
  }
#  A<-matrix(runif(u*r), nrow=r, ncol=u)
#  B<-qr.Q(qr(A), complete=TRUE)
  return(as.matrix(qr.Q(qr(matrix(runif(u*r), nrow=r, ncol=u)),
                        complete=TRUE)[,1:u]))

}


#' Compute the Frobenius norm between two bases.
#'
#' Input the bases will suffice!
#'
#' @param base1,base2 Two semi-orthogonal basis matrices.
#' @return The Frobenius norm of the difference of their projection matrices.
frbnorm<-function(base1, base2){

  if(any(dim(base1)!=dim(base2))){
    stop("Two matrices are not of the same dimension!")
  }

#  dis<-tcrossprod(base1)-tcrossprod(base2)
#  return(sqrt(sum(dis^2)))
  return(sqrt(sum((tcrossprod(base1, NULL)-tcrossprod(base2, NULL))^2)))

}

#' An "Angle" Between Two Semi-orthogonal Bases
#'
#' A possible problem: when measuring results by data of population version, the
#' singular value may exceed 1 and thus \code{NaN} is produces by \code{\link{acos}}.
#'
#' @param base1,base2 Two semi-orthogonal matrices.
#' @return The value of the "angle".
angle<-function(base1, base2){

  if(any((dims<-dim((base1)))!=dim(base2))){
    stop("Two matrices are not of the same dimension!")
  }

#  sinval<-svd(crossprod(base1, base2))$d[dims[2]]
  return(acos(svd(crossprod(base1, base2))$d[dims[2]])*180/pi)
}


#' Projection Matrix
#'
#' @param prodmat The projection is relative to what inner product? The standard
#' inner product, the default.
#' @param rank Rank of the matrix. Used in \code{\link{mpinv}}. If null, will be
#' selected in \code{\link{mpinv}}.
#' @param tol Set it case by case.
Pr<-function(mat, prodmat=diag(dim(mat)[1]), rank=NULL, tol=.Machine$double.eps^0.75){

  return(mat%*%mpinv(X=crossprod(mat, (prodmat%*%mat)), rank=rank, tol=tol)$inv%*%t(prodmat%*%mat))

}

#' Minus Square Root Matrix
#'
#' @param mat MUST be positive definite.
msqr<-function(mat){

  eig.mat<-eigen(mat, symmetric=T)
  return(sweep(eig.mat$vectors, MARGIN=2, 1/sqrt(eig.mat$values), "*")%*%t(eig.mat$vectors))

}

#' Vector Correlation Coefficient
#'
#' @param A,B Semi-orthogonal matrices of the same dimension.
vec_cor<-function(A, B){

  if(any(dim(A)!=dim(B))){
    stop("Two matrices are not of the same dimension!")
  }

#  qsqua<-prod(eigen(crossprod(crossprod(A,B)), only.values=T)$values)
  return(prod(eigen(crossprod(crossprod(A,B)), only.values=T)$values))
}

#' MP Inverse
#'
#' The Moore-Penrose inverse. Mainly copied from \code{\link[MASS]{ginv}}.
#'
#' @param rank Specify the rank of the matrix. If null, then rank will be selected,
#' just as the original \code{ginv} function does.
mpinv<-function (X, rank=NULL, tol=sqrt(.Machine$double.eps))
{
  if (length(dim(X)) > 2L || !(is.numeric(X) || is.complex(X)))
    stop("'X' must be a numeric or complex matrix")
  if (!is.matrix(X))
    X <- as.matrix(X)

  Xsvd <- svd(X)
#  if (is.complex(X))  # Redundant?
#    Xsvd$u <- Conj(Xsvd$u)

  if(is.null(rank))
    Positive <- Xsvd$d > max(tol * Xsvd$d[1L], 0)
  else {
    Positive<-Xsvd$d<0
    Positive[1:rank]<-T
  }


  if (all(Positive))
    resu_inv<-Xsvd$v %*% (1/Xsvd$d * t(Xsvd$u))
  else if (!any(Positive))
    resu_inv<-array(0, dim(X)[2L:1L])
  else
    resu_inv<-Xsvd$v[,Positive,drop=F]%*%((1/Xsvd$d[Positive])*t(Xsvd$u[, Positive, drop=F]))

  return(list(inv=resu_inv, Positive=Positive))

}
